[{"content":"The list includes things that I consider important enough to require me to update the page. üòÖ.\nThe dates next to some of the items represents the date in which I finished the book, movie or course.\nBooks  Atomic Habits by James Clear - 30.01.2022 Grooking Algorithms by Aditya Y. Bahrgava via Manning - 13.03.2022  Podcasts  Go Time Podcast by Changelog Media The Changelog by Changelog Media Pivot by The New York Magazine Ardan Labs Podcast by Ardan Labs  Youtube Channels  Coldfusion by Dagogo Altraide Bloomberg Quicktake by Bloomberg L.P. .cult by Honeypot - .cult dedicated website NoClip by NoClip TV Ardan Labs by Ardab Labs  Newsletters  Chunchbase daily by Crunchbase Golang Weekly by Cooperpress Laravel newsletter by Laravel news Stitcher.io by Brent GD  ","permalink":"https://victoravelar.dev/articles/2022-yearbook/","summary":"The list includes things that I consider important enough to require me to update the page. üòÖ.\nThe dates next to some of the items represents the date in which I finished the book, movie or course.\nBooks  Atomic Habits by James Clear - 30.01.2022 Grooking Algorithms by Aditya Y. Bahrgava via Manning - 13.03.2022  Podcasts  Go Time Podcast by Changelog Media The Changelog by Changelog Media Pivot by The New York Magazine Ardan Labs Podcast by Ardan Labs  Youtube Channels  Coldfusion by Dagogo Altraide Bloomberg Quicktake by Bloomberg L.","title":"2022 Yearbook"},{"content":" The book comes with code samples using python, I did my best to rewrite most of them using golang.\nSome of the most complex exercises deserve its own article and I will try to do so.\nIf you find the notes interesting, you should consider getting a copy of the book.\n  ‚ö†Ô∏è This is a work in progress, you can expect the article to grow.  Chapter 1 - Introduction An algorith is a set of instructions for accomplishing a task. Every piece of code could be called an algorithm.\nBinary Search Binary search is an algorithm that receives a sorted list as input (‚ö†Ô∏è binary search won\u0026rsquo;t work if the list is not sorted.) and a search subject. It returns the position in the list where the search subject is located.\n// This is go(ish) pseudo code. list := []int{5,10,15,20, 25}  fmt.Println(binarySearch(list, 10)) // Output: 1 In general, for any list of size n, binary search will take log n steps to run in the worst case. In comparison, linear search will take n steps.\n üí° When speaking about time/space complexity the logarithm is always base 2\n Using it in go There are the three custom binary search functions: sort.SearchInts, sort.SearchStrings or sort.SearchFloat64s.\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;sort\u0026#34; )  func main() {  list := []int{5,10,15,20, 25}   fmt.Println(sort.SearchInts(list, 10)) } Go playground: https://go.dev/play/p/22tGiSz-z6D\nüí° Go 1.18 and generics Starting from v1.18 generics support is available in Go, with this release also an experimental package arrived that offers a \u0026ldquo;general\u0026rdquo; binary search implementation for slices.\nIn the long run this implementation should replace the 3 functions available in v1.17 and before.\n Slice pkg: https://pkg.go.dev/golang.org/x/exp/slices#BinarySearch  Binary search is an extract from the original implementation üîù\n// BinarySearch searches for target in a sorted slice and returns the smallest // index at which target is found. If the target is not found, the index at // which it could be inserted into the slice is returned; therefore, if the // intention is to find target itself a separate check for equality with the // element at the returned index is required. func BinarySearch[Elem constraints.Ordered](x []Elem, target Elem) int { \treturn search(len(x), func(i int) bool { return x[i] \u0026gt;= target }) }  // where search is defined as func search(n int, f func(int) bool) int { \t// Define f(-1) == false and f(n) == true. \t// Invariant: f(i-1) == false, f(j) == true. \ti, j := 0, n \tfor i \u0026lt; j { \th := int(uint(i+j) \u0026gt;\u0026gt; 1) // avoid overflow when computing h \t// i ‚â§ h \u0026lt; j \tif !f(h) { \ti = h + 1 // preserves f(i-1) == false \t} else { \tj = h // preserves f(j) == true \t} \t} \t// i == j, f(i-1) == false, and f(j) (= f(i)) == true =\u0026gt; answer is i. \treturn i }  --- // and then it can be used as follows list := []int{5,10,15,20,25} want := 10  if idx := BinarySearch(list, want); list[idx] == want {  return idx } else {  return nil } Running time Generally you want to choose the most efficient algorithm whether you\u0026rsquo;re optimizing for time or space.\nBig O It\u0026rsquo;s a special notation that tells you the rate in which the execution time or the necessary space grows.\n üí° Big O notation is about the worst case-scenario.\n Common notations are:\n O(1) or constant O(n) or linear O(n^2) or quadratic O(log n) or logarithmic O(2^n) or exponential O(n!) or factorial O(n log n) or linearithmic  üìå n == len(list)\nExample: Operations performed for lists of size 1, 8, 64, and 1024.\n   Big O len(1) len(8) len(64) len(1024)     O(1) 1 1 1 1   O(n) 1 8 64 1024   O(n^2) 1 64 4096 1048576   O(log n) 1 3 6 10   O(2^n) 1 256 1.8446744 x 10^19 1.797693134862315907729305190789 x 10^308   O(n!) 1 40320 1.2688693 X 10^89 infinity (too big to compute)   O(n log n) 1 24 384 10240    Chapter 2 - Selection sort How memory works Each time you want to store something in memory, you need to ask the computer for some space, then you will get the address of the next available memory slot and you can store your information in there.\n// We are telling go to store 100 as a variable which will use memory space variable := 100  // If we want to get the address in memory for our variable we need to do this address := \u0026amp;variable  println(address, variable) // outputs something like 0xc00003c768 100 Arrays and linked lists Linked lists A linked list contains a reference to the location of the next item in the list, this way a bunch of memory addresses can be linked together.\nExample:\na-\u0026gt;b-\u0026gt;c-\u0026gt;d-\u0026gt;null This feature allow items to be stored anywhere in memory, you can always reach them using the address stored in the list.\nArrays An array is a continous list stored in memory where you know the location and value of all items.\nExample:\n[]int{0,1,2,3,4} This forces an array to allocate continous space in memory leading to data relocation when more space is needed and no contigous space in memory is available.\nArrays vs Linked lists  Arrays are great if you want to read random or non-contigous elements. Linked lists are great if you are going to read all the items one at a time.  Terminology The elements in an array are numbered, most programming languages start with 0 and not 1. When you see a reference to an array element located at index 1 it is refering to the second element of the array and not the first one.\n üí° The position of an element in an array is called index.\n These are the run times for common operations on arrays and linked lists:\n    Arrays Lists     Reading O(1) O(n)   Insertion O(n) O(1)    Insertions Whit lists it is easy to insert, you need to change the pointers to the next and current elements.\ntype node struct { \tValue int \tNext *node }  root := node{10, nil}  // Imagine we need to insert another node into our list root.Next = \u0026amp;node{5, nil}  // Imagine we need to insert another node into our list root.Next = \u0026amp;node{5, nil}  fmt.Printf(\u0026#34;root is %v and next is %v\\n\u0026#34;, root, root.Next) // Output: root is {10 0xc000108050} and next is \u0026amp;{5 \u0026lt;nil\u0026gt;}  // Lets imagine now they asks us to insert a new node with value 8 after the first node.  n := \u0026amp;node{8, nil} n.Next = root.Next root.Next = n fmt.Printf(\u0026#34;root is %v and next is %v, and next.Next is %v\u0026#34;, root, root.Next, root.Next.Next) // Output: root is {10 0xc000096260} and next is \u0026amp;{8 0xc000096230}, and next.Next is \u0026amp;{5 \u0026lt;nil\u0026gt;} Go playground: https://go.dev/play/p/V_zOwyM936O\nDeletions When it comes to deletions the situation doesn\u0026rsquo;t change much, lists are better, you just need to move the pointer and üí£ an item is off the list.\n// main() type node struct { \tVal int \tNext *node }  root := \u0026amp;node{10, nil}  root.Next = \u0026amp;node{9, nil}  root.Next.Next = \u0026amp;node{8, nil}  n := root  for n != nil { \tfmt.Println(n.Val) \tn = n.Next }  // Now let\u0026#39;s suppose we only want even numbers in our list, // so we need to remove the 9  root.Next = root.Next.Next  n = root  for n != nil { \tfmt.Println(n.Val) \tn = n.Next } Go playground: https://go.dev/play/p/HWwpT8tteu1\nWith arrays everything needs to be moved but unlike insertions deletions will always work.\n üí° array insertions can fail when there is no more space in memory and the array cannot be dynamically extended.\n üîñ It is a common practice to keep track of the first and last element of a linked list, that way removing or inserting at the start / end of the list is always O(1).\nThere are two different types of access, random access and sequential access.\nüìå Linked lists can only do sequential access\nüìå Arrays are better if you need random access\n üí° Random access means that you can inmmediatly jump to any point of the array.\n arr := []int{1,2,3,4,5}  // Random access to 4 arr[3] // prints 4  // With a list you will get sequential access: // Image the list above is represented using linked nodes: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;nil root.Next.Next.Next // prints 4 Common run time for operations on arrays and linked lists.\n    Arrays Lists     Reading O(1) O(n)   Writing O(n) 0(1)   Deleting O(n) O(1)    Selection sort Given a comparable value sort by picking the highest (desc) / lowest (asc) value and moving it to the righ position, this is know as in place sorting, do this until your list is sorted.\n// Sort the given array arr := []int{20,234,2,23,90,4}  func selectionSort(list []int) []int { \tvar n = len(list) \tfor i := 0; i \u0026lt; n; i++ { \tvar minIdx = i \tfor j := i; j \u0026lt; n; j++ { \tif list[j] \u0026lt; list[minIdx] { \tminIdx = j \t} \t} \tlist[i], list[minIdx] = list[minIdx], list[i]  \t// See how the array changes on every pass. \tfmt.Println(list) \t}  \treturn list }  // main() fmt.Println(selectionSort(arr)) Go playground: https://go.dev/play/p/FHhposwF6Nk\nChapter 3 - Recursion In computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem.\nTo be able to write a recursive function, you need one or several base cases and one recursive case, in plain words this means that your function needs rules to know when to stop and what to do when those rules are not met.\nThe most famous example to practice recursion is creating a function that returns the nth number in Fibonnaci\u0026rsquo;s sequence:\n func nthFib(n int) int { \t// Initial base case, when the requested number is 0 we know \t// we don\u0026#39;t need to do any work. \tif n == 0 { \treturn 0 \t}  \t// Another base case: The first 2 fib numbers after 0 are 1 \t// 0 1 1 \tif n \u0026lt;=2 { \treturn 1 \t}  \t// Now we need to write our recursive case, we now fib sequence is created \t// by adding the 2 previous numbers before the one you need. \t// \t// To illustrate let\u0026#39;s calculate the first 5 fib numbers/ \t// 0, 1, 1, 2, 3, 5. \t// From that example we visualize that the fifth fib number is creating by \t// adding the numbers at position 4 and 3, or 3 + 2. \t// Therefore we can create our recursive case by saying: \treturn nthFib(n - 1) + nthFib(n - 2) \t// This code will always work because we now that in order to hit our recursive \t// case our n number needs to be \u0026gt; 0. } Go playground: https://go.dev/play/p/Y5Vdg6VcMUW\n","permalink":"https://victoravelar.dev/articles/my-notes-on-grooking-algorithms/","summary":"The book comes with code samples using python, I did my best to rewrite most of them using golang.\nSome of the most complex exercises deserve its own article and I will try to do so.\nIf you find the notes interesting, you should consider getting a copy of the book.\n  ‚ö†Ô∏è This is a work in progress, you can expect the article to grow.  Chapter 1 - Introduction An algorith is a set of instructions for accomplishing a task.","title":"My Notes on Grooking Algorithms"}]