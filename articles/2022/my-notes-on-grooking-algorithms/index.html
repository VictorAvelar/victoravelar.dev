<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>My Notes on Grooking Algorithms | VictorAvelar</title><meta name=keywords content="algorithms"><meta name=description content="Grooking algorithms is an illustrated guide on algorithms and data structures."><meta name=author content="Victor Avelar"><link rel=canonical href=https://victoravelar.dev/articles/2022/my-notes-on-grooking-algorithms/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://victoravelar.dev/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://victoravelar.dev/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://victoravelar.dev/favicon-32x32.png><link rel=apple-touch-icon href=https://victoravelar.dev/apple-touch-icon.png><link rel=mask-icon href=https://victoravelar.dev/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://victoravelar.dev/articles/2022/my-notes-on-grooking-algorithms/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://victoravelar.dev/articles/2022/my-notes-on-grooking-algorithms/"><meta property="og:site_name" content="VictorAvelar"><meta property="og:title" content="My Notes on Grooking Algorithms"><meta property="og:description" content="Grooking algorithms is an illustrated guide on algorithms and data structures."><meta property="og:locale" content="en-GB"><meta property="og:type" content="article"><meta property="article:section" content="articles"><meta property="article:published_time" content="2022-03-16T15:14:08+01:00"><meta property="article:modified_time" content="2022-03-16T15:14:08+01:00"><meta property="article:tag" content="Algorithms"><meta property="og:image" content="https://images.manning.com/book/3/0b325da-eb26-4e50-8a2a-46042c647083/Bhargava-Algorithms_hires.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.manning.com/book/3/0b325da-eb26-4e50-8a2a-46042c647083/Bhargava-Algorithms_hires.png"><meta name=twitter:title content="My Notes on Grooking Algorithms"><meta name=twitter:description content="Grooking algorithms is an illustrated guide on algorithms and data structures."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Articles","item":"https://victoravelar.dev/articles/"},{"@type":"ListItem","position":2,"name":"My Notes on Grooking Algorithms","item":"https://victoravelar.dev/articles/2022/my-notes-on-grooking-algorithms/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"My Notes on Grooking Algorithms","name":"My Notes on Grooking Algorithms","description":"Grooking algorithms is an illustrated guide on algorithms and data structures.","keywords":["algorithms"],"articleBody":" The book comes with code samples using python, I did my best to rewrite most of them using golang.\nSome of the most complex exercises deserve its own article and I will try to do so.\nIf you find the notes interesting, you should consider getting a copy of the book.\n‚ö†Ô∏è This is a work in progress, you can expect the article to grow. Chapter 1 - Introduction An algorith is a set of instructions for accomplishing a task. Every piece of code could be called an algorithm.\nBinary Search Binary search is an algorithm that receives a sorted list as input (‚ö†Ô∏è binary search won‚Äôt work if the list is not sorted.) and a search subject. It returns the position in the list where the search subject is located.\n// This is go(ish) pseudo code. list := []int{5,10,15,20, 25} fmt.Println(binarySearch(list, 10)) // Output: 1 In general, for any list of size n, binary search will take log n steps to run in the worst case. In comparison, linear search will take n steps.\nüí° When speaking about time/space complexity the logarithm is always base 2\nUsing it in go There are the three custom binary search functions: sort.SearchInts, sort.SearchStrings or sort.SearchFloat64s.\npackage main import ( \"fmt\" \"sort\" ) func main() { list := []int{5,10,15,20, 25} fmt.Println(sort.SearchInts(list, 10)) } Go playground: https://go.dev/play/p/22tGiSz-z6D\nüí° Go 1.18 and generics Starting from v1.18 generics support is available in Go, with this release also an experimental package arrived that offers a ‚Äúgeneral‚Äù binary search implementation for slices.\nIn the long run this implementation should replace the 3 functions available in v1.17 and before.\nSlice pkg: https://pkg.go.dev/golang.org/x/exp/slices#BinarySearch Binary search is an extract from the original implementation üîù\n// BinarySearch searches for target in a sorted slice and returns the smallest // index at which target is found. If the target is not found, the index at // which it could be inserted into the slice is returned; therefore, if the // intention is to find target itself a separate check for equality with the // element at the returned index is required. func BinarySearch[Elem constraints.Ordered](x []Elem, target Elem) int { return search(len(x), func(i int) bool { return x[i] \u003e= target }) } // where search is defined as func search(n int, f func(int) bool) int { // Define f(-1) == false and f(n) == true. // Invariant: f(i-1) == false, f(j) == true. i, j := 0, n for i \u003c j { h := int(uint(i+j) \u003e\u003e 1) // avoid overflow when computing h // i ‚â§ h \u003c j if !f(h) { i = h + 1 // preserves f(i-1) == false } else { j = h // preserves f(j) == true } } // i == j, f(i-1) == false, and f(j) (= f(i)) == true =\u003e answer is i. return i } --- // and then it can be used as follows list := []int{5,10,15,20,25} want := 10 if idx := BinarySearch(list, want); list[idx] == want { return idx } else { return nil } Running time Generally you want to choose the most efficient algorithm whether you‚Äôre optimizing for time or space.\nBig O It‚Äôs a special notation that tells you the rate in which the execution time or the necessary space grows.\nüí° Big O notation is about the worst case-scenario.\nCommon notations are:\nO(1) or constant O(n) or linear O(n^2) or quadratic O(log n) or logarithmic O(2^n) or exponential O(n!) or factorial O(n log n) or linearithmic üìå n == len(list)\nExample: Operations performed for lists of size 1, 8, 64, and 1024.\nBig O len(1) len(8) len(64) len(1024) O(1) 1 1 1 1 O(n) 1 8 64 1024 O(n^2) 1 64 4096 1048576 O(log n) 1 3 6 10 O(2^n) 1 256 1.8446744 x 10^19 1.797693134862315907729305190789 x 10^308 O(n!) 1 40320 1.2688693 X 10^89 infinity (too big to compute) O(n log n) 1 24 384 10240 Chapter 2 - Selection sort How memory works Each time you want to store something in memory, you need to ask the computer for some space, then you will get the address of the next available memory slot and you can store your information in there.\n// We are telling go to store 100 as a variable which will use memory space variable := 100 // If we want to get the address in memory for our variable we need to do this address := \u0026variable println(address, variable) // outputs something like 0xc00003c768 100 Arrays and linked lists Linked lists A linked list contains a reference to the location of the next item in the list, this way a bunch of memory addresses can be linked together.\nExample:\na-\u003eb-\u003ec-\u003ed-\u003enull This feature allow items to be stored anywhere in memory, you can always reach them using the address stored in the list.\nArrays An array is a continous list stored in memory where you know the location and value of all items.\nExample:\n[]int{0,1,2,3,4} This forces an array to allocate continous space in memory leading to data relocation when more space is needed and no contigous space in memory is available.\nArrays vs Linked lists Arrays are great if you want to read random or non-contigous elements. Linked lists are great if you are going to read all the items one at a time. Terminology The elements in an array are numbered, most programming languages start with 0 and not 1. When you see a reference to an array element located at index 1 it is refering to the second element of the array and not the first one.\nüí° The position of an element in an array is called index.\nThese are the run times for common operations on arrays and linked lists:\nArrays Lists Reading O(1) O(n) Insertion O(n) O(1) Insertions Whit lists it is easy to insert, you need to change the pointers to the next and current elements.\ntype node struct { Value int Next *node } root := node{10, nil} // Imagine we need to insert another node into our list root.Next = \u0026node{5, nil} // Imagine we need to insert another node into our list root.Next = \u0026node{5, nil} fmt.Printf(\"root is %v and next is %v\\n\", root, root.Next) // Output: root is {10 0xc000108050} and next is \u0026{5 } // Lets imagine now they asks us to insert a new node with value 8 after the first node. n := \u0026node{8, nil} n.Next = root.Next root.Next = n fmt.Printf(\"root is %v and next is %v, and next.Next is %v\", root, root.Next, root.Next.Next) // Output: root is {10 0xc000096260} and next is \u0026{8 0xc000096230}, and next.Next is \u0026{5 } Go playground: https://go.dev/play/p/V_zOwyM936O\nDeletions When it comes to deletions the situation doesn‚Äôt change much, lists are better, you just need to move the pointer and üí£ an item is off the list.\n// main() type node struct { Val int Next *node } root := \u0026node{10, nil} root.Next = \u0026node{9, nil} root.Next.Next = \u0026node{8, nil} n := root for n != nil { fmt.Println(n.Val) n = n.Next } // Now let's suppose we only want even numbers in our list, // so we need to remove the 9 root.Next = root.Next.Next n = root for n != nil { fmt.Println(n.Val) n = n.Next } Go playground: https://go.dev/play/p/HWwpT8tteu1\nWith arrays everything needs to be moved but unlike insertions deletions will always work.\nüí° array insertions can fail when there is no more space in memory and the array cannot be dynamically extended.\nüîñ It is a common practice to keep track of the first and last element of a linked list, that way removing or inserting at the start / end of the list is always O(1).\nThere are two different types of access, random access and sequential access.\nüìå Linked lists can only do sequential access\nüìå Arrays are better if you need random access\nüí° Random access means that you can inmmediatly jump to any point of the array.\narr := []int{1,2,3,4,5} // Random access to 4 arr[3] // prints 4 // With a list you will get sequential access: // Image the list above is represented using linked nodes: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003enil root.Next.Next.Next // prints 4 Common run time for operations on arrays and linked lists.\nArrays Lists Reading O(1) O(n) Writing O(n) 0(1) Deleting O(n) O(1) Selection sort Given a comparable value sort by picking the highest (desc) / lowest (asc) value and moving it to the righ position, this is know as in place sorting, do this until your list is sorted.\n// Sort the given array arr := []int{20,234,2,23,90,4} func selectionSort(list []int) []int { var n = len(list) for i := 0; i \u003c n; i++ { var minIdx = i for j := i; j \u003c n; j++ { if list[j] \u003c list[minIdx] { minIdx = j } } list[i], list[minIdx] = list[minIdx], list[i] // See how the array changes on every pass. fmt.Println(list) } return list } // main() fmt.Println(selectionSort(arr)) Go playground: https://go.dev/play/p/FHhposwF6Nk\nChapter 3 - Recursion In computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem.\nTo be able to write a recursive function, you need one or several base cases and one recursive case, in plain words this means that your function needs rules to know when to stop and what to do when those rules are not met.\nThe most famous example to practice recursion is creating a function that returns the nth number in Fibonnaci‚Äôs sequence:\nfunc nthFib(n int) int { // Initial base case, when the requested number is 0 we know // we don't need to do any work. if n == 0 { return 0 } // Another base case: The first 2 fib numbers after 0 are 1 // 0 1 1 if n \u003c=2 { return 1 } // Now we need to write our recursive case, we know the fib sequence is created // by adding the 2 previous numbers before the one you need. // // To illustrate, let's calculate the first 5 fib numbers: // 0, 1, 1, 2, 3, 5. // From that example we visualize that the fifth fib number is creating by // adding the numbers at position 4 and 3, or 3 + 2. // Therefore we can create our recursive case by saying: return nthFib(n - 1) + nthFib(n - 2) // This code will always work because we now that in order to hit our recursive // case our n number needs to be \u003e 0. } Go playground: https://go.dev/play/p/Y5Vdg6VcMUW\nThe stack A stack is a data structure where new information is pushed to the front of the stack and when you need to retrieve a workload, you will always take whatever is at the very top of the stack.\nExample:\n// considering we have push and read as functions and: // push adds information to the top of our stack while read // retrieves the record at the top, then. stack.push(1) stack.push(10) stack.push(7) println(stack.read()) // prints 7 Your computer performs processes using an internal stack knwon as the call stack, it will allocate a stack frame for every action it needs to perform.\nRecursion and the call stack Recursive functions leverage the internal call stack to avoid using additional data structures.\nImagine a function called factorial(int num) int that calculates the factorial value of the given number, to write it in a recursive way we do something like:\nfunc factorial(int num) int { // declare your base case if num == 1 { return 1 } // declare your recursive case return num * factorial(num - 1) } Let‚Äôs check how the call stack will be used to calculate the result of factorial(3)\non the stack I will use f to refer to factorial\nCode Stack factorial(3) f(3) factorial(2) f(3) -\u003e f(2) factorial(1) f(3) -\u003e f(2) -\u003e f(1) (base case) = return 1 f(3) -\u003e f(2) (2 * 1) = return 2 f(3) (3 * 2) = return 6 (empty) See how first the program performs three calls to factorial and then starts using the result to compute the subsequent still pending calls in the stack.\nAlternatives to stacks Write your code using loops You can use tail recursion (advanced) (not supported by all programming languages) ","wordCount":"2048","inLanguage":"en","image":"https://images.manning.com/book/3/0b325da-eb26-4e50-8a2a-46042c647083/Bhargava-Algorithms_hires.png","datePublished":"2022-03-16T15:14:08+01:00","dateModified":"2022-03-16T15:14:08+01:00","author":{"@type":"Person","name":"Victor Avelar"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://victoravelar.dev/articles/2022/my-notes-on-grooking-algorithms/"},"publisher":{"@type":"Organization","name":"VictorAvelar","logo":{"@type":"ImageObject","url":"https://victoravelar.dev/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://victoravelar.dev/ accesskey=h title="VictorAvelar (Alt + H)">VictorAvelar</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://victoravelar.dev/categories/ title=categories><span>categories</span></a></li><li><a href=https://victoravelar.dev/tags/ title=tags><span>tags</span></a></li><li><a href=https://victoravelar.dev/archive/ title=archive><span>archive</span></a></li><li><a href=https://victoravelar.dev/uses/ title=uses><span>uses</span></a></li><li><a href=https://victoravelar.dev/search/ title="üîç (Alt + /)" accesskey=/><span>üîç</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://victoravelar.dev/>Home</a>&nbsp;¬ª&nbsp;<a href=https://victoravelar.dev/articles/>Articles</a></div><h1 class="post-title entry-hint-parent">My Notes on Grooking Algorithms</h1><div class=post-description>Grooking algorithms is an illustrated guide on algorithms and data structures.</div><div class=post-meta><span title='2022-03-16 15:14:08 +0100 +0100'>16 March 2022</span>&nbsp;¬∑&nbsp;<span>10 min</span>&nbsp;¬∑&nbsp;<span>Victor Avelar</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/VictorAvelar/victoravelar.dev/content/articles/2022/my-notes-on-grooking-algorithms.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><figure class=entry-cover><img loading=eager src=https://images.manning.com/book/3/0b325da-eb26-4e50-8a2a-46042c647083/Bhargava-Algorithms_hires.png alt=Bhargava-Algorithms><figcaption>Grookign algorithms by Aditya Bhargava</figcaption></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><ul><li><a href=#warning-this-is-a-work-in-progress-you-can-expect-the-article-to-grow aria-label="&#9888;&#xfe0f; This is a work in progress, you can expect the article to grow.">&#9888;&#xfe0f; This is a work in progress, you can expect the article to grow.</a></li></ul></ul><li><a href=#chapter-1---introduction aria-label="Chapter 1 - Introduction">Chapter 1 - Introduction</a><ul><li><a href=#binary-search aria-label="Binary Search">Binary Search</a><ul><li><a href=#using-it-in-go aria-label="Using it in go">Using it in go</a></li><li><a href=#bulb-go-118-and-generics aria-label="&#x1f4a1; Go 1.18 and generics">&#x1f4a1; Go 1.18 and generics</a></li></ul></li><li><a href=#running-time aria-label="Running time">Running time</a></li><li><a href=#big-o aria-label="Big O">Big O</a></li></ul></li><li><a href=#chapter-2---selection-sort aria-label="Chapter 2 - Selection sort">Chapter 2 - Selection sort</a><ul><li><a href=#how-memory-works aria-label="How memory works">How memory works</a></li><li><a href=#arrays-and-linked-lists aria-label="Arrays and linked lists">Arrays and linked lists</a><ul><li><a href=#linked-lists aria-label="Linked lists">Linked lists</a></li><li><a href=#arrays aria-label=Arrays>Arrays</a></li><li><a href=#arrays-vs-linked-lists aria-label="Arrays vs Linked lists">Arrays vs Linked lists</a></li><li><a href=#terminology aria-label=Terminology>Terminology</a></li><li><a href=#insertions aria-label=Insertions>Insertions</a></li><li><a href=#deletions aria-label=Deletions>Deletions</a></li><li><a href=#bookmark aria-label=&#x1f516;>&#x1f516;</a></li></ul></li><li><a href=#selection-sort aria-label="Selection sort">Selection sort</a></li><li><a href=#chapter-3---recursion aria-label="Chapter 3 - Recursion">Chapter 3 - Recursion</a><ul><li><a href=#the-stack aria-label="The stack">The stack</a></li><li><a href=#recursion-and-the-call-stack aria-label="Recursion and the call stack">Recursion and the call stack</a></li><li><a href=#alternatives-to-stacks aria-label="Alternatives to stacks">Alternatives to stacks</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>The book comes with code samples using python, I did my best to rewrite most of them using golang.</p><p>Some of the most complex exercises deserve its own article and I will try to do so.</p><p>If you find the notes interesting, you should consider <a href=https://www.manning.com/books/grokking-algorithms>getting a copy of the book</a>.</p></blockquote><blockquote><h3 id=warning-this-is-a-work-in-progress-you-can-expect-the-article-to-grow>&#9888;&#xfe0f; This is a work in progress, you can expect the article to grow.<a hidden class=anchor aria-hidden=true href=#warning-this-is-a-work-in-progress-you-can-expect-the-article-to-grow>#</a></h3></blockquote><h1 id=chapter-1---introduction>Chapter 1 - Introduction<a hidden class=anchor aria-hidden=true href=#chapter-1---introduction>#</a></h1><p>An algorith is a set of instructions for accomplishing a task. Every piece of code could be called an algorithm.</p><h2 id=binary-search>Binary Search<a hidden class=anchor aria-hidden=true href=#binary-search>#</a></h2><p>Binary search is an algorithm that receives a sorted list as input (&#9888;&#xfe0f; binary search won&rsquo;t work if the list is not sorted.) and a search subject. It returns the position in the list where the search subject is located.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// This is go(ish) pseudo code.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>list</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>15</span>,<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>25</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>binarySearch</span>(<span style=color:#a6e22e>list</span>, <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span><span style=color:#75715e>// Output: 1</span>
</span></span></code></pre></div><p>In general, for any list of size <code>n</code>, binary search will take <code>log n</code> steps to run in the worst case. In comparison, linear search will take <code>n</code> steps.</p><blockquote><p>&#x1f4a1; When speaking about time/space complexity the logarithm is always base 2</p></blockquote><h3 id=using-it-in-go>Using it in go<a hidden class=anchor aria-hidden=true href=#using-it-in-go>#</a></h3><p>There are the three custom binary search functions: <a href=https://golang.org/pkg/sort/#SearchInts>sort.SearchInts</a>, <a href=https://golang.org/pkg/sort/#SearchStrings>sort.SearchStrings</a> or <a href=https://golang.org/pkg/sort/#SearchFloat64s>sort.SearchFloat64s</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;sort&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>list</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>15</span>,<span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>25</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sort</span>.<span style=color:#a6e22e>SearchInts</span>(<span style=color:#a6e22e>list</span>, <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Go playground: <a href=https://go.dev/play/p/22tGiSz-z6D>https://go.dev/play/p/22tGiSz-z6D</a></p><h3 id=bulb-go-118-and-generics>&#x1f4a1; Go 1.18 and generics<a hidden class=anchor aria-hidden=true href=#bulb-go-118-and-generics>#</a></h3><p>Starting from v1.18 generics support is available in Go, with this release also an experimental package arrived that offers a <em>&ldquo;general&rdquo;</em> binary search implementation for slices.</p><p>In the long run this implementation should replace the 3 functions available in v1.17 and before.</p><ul><li>Slice pkg: <a href=https://pkg.go.dev/golang.org/x/exp/slices#BinarySearch>https://pkg.go.dev/golang.org/x/exp/slices#BinarySearch</a></li></ul><p>Binary search is an extract from the original implementation &#x1f51d;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// BinarySearch searches for target in a sorted slice and returns the smallest</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// index at which target is found. If the target is not found, the index at</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// which it could be inserted into the slice is returned; therefore, if the</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// intention is to find target itself a separate check for equality with the</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// element at the returned index is required.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BinarySearch</span>[<span style=color:#a6e22e>Elem</span> <span style=color:#a6e22e>constraints</span>.<span style=color:#a6e22e>Ordered</span>](<span style=color:#a6e22e>x</span> []<span style=color:#a6e22e>Elem</span>, <span style=color:#a6e22e>target</span> <span style=color:#a6e22e>Elem</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>search</span>(len(<span style=color:#a6e22e>x</span>), <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>target</span> })
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// where search is defined as</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>search</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>f</span> <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Define f(-1) == false and f(n) == true.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Invariant: f(i-1) == false, f(j) == true.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>j</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>h</span> <span style=color:#f92672>:=</span> int(uint(<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#a6e22e>j</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#75715e>// avoid overflow when computing h</span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// i ‚â§ h &lt; j</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>f</span>(<span style=color:#a6e22e>h</span>) {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>i</span> = <span style=color:#a6e22e>h</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>// preserves f(i-1) == false</span>
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>j</span> = <span style=color:#a6e22e>h</span> <span style=color:#75715e>// preserves f(j) == true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#75715e>// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =&gt;  answer is i.</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>---</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// and then it can be used as follows</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>list</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>15</span>,<span style=color:#ae81ff>20</span>,<span style=color:#ae81ff>25</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>want</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>idx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>BinarySearch</span>(<span style=color:#a6e22e>list</span>, <span style=color:#a6e22e>want</span>); <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>idx</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>want</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>idx</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=running-time>Running time<a hidden class=anchor aria-hidden=true href=#running-time>#</a></h2><p>Generally you want to choose the most efficient algorithm whether you&rsquo;re optimizing for time or space.</p><h2 id=big-o>Big O<a hidden class=anchor aria-hidden=true href=#big-o>#</a></h2><p>It&rsquo;s a special notation that tells you the rate in which the execution time or the necessary space grows.</p><blockquote><p>&#x1f4a1; Big O notation is about the worst case-scenario.</p></blockquote><p>Common notations are:</p><ul><li><code>O(1)</code> or constant</li><li><code>O(n)</code> or linear</li><li><code>O(n^2)</code> or quadratic</li><li><code>O(log n)</code> or logarithmic</li><li><code>O(2^n)</code> or exponential</li><li><code>O(n!)</code> or factorial</li><li><code>O(n log n)</code> or linearithmic</li></ul><p>&#x1f4cc; <code>n</code> == <code>len(list)</code></p><p>Example: Operations performed for lists of size 1, 8, 64, and 1024.</p><table><thead><tr><th>Big O</th><th>len(1)</th><th>len(8)</th><th>len(64)</th><th>len(1024)</th></tr></thead><tbody><tr><td>O(1)</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>O(n)</td><td>1</td><td>8</td><td>64</td><td>1024</td></tr><tr><td>O(n^2)</td><td>1</td><td>64</td><td>4096</td><td>1048576</td></tr><tr><td>O(log n)</td><td>1</td><td>3</td><td>6</td><td>10</td></tr><tr><td>O(2^n)</td><td>1</td><td>256</td><td>1.8446744 x 10^19</td><td>1.797693134862315907729305190789 x 10^308</td></tr><tr><td>O(n!)</td><td>1</td><td>40320</td><td>1.2688693 X 10^89</td><td>infinity (too big to compute)</td></tr><tr><td>O(n log n)</td><td>1</td><td>24</td><td>384</td><td>10240</td></tr></tbody></table><h1 id=chapter-2---selection-sort>Chapter 2 - Selection sort<a hidden class=anchor aria-hidden=true href=#chapter-2---selection-sort>#</a></h1><h2 id=how-memory-works>How memory works<a hidden class=anchor aria-hidden=true href=#how-memory-works>#</a></h2><p>Each time you want to store something in memory, you need to ask the computer for some space, then you will get the address of the next available memory slot and you can store your information in there.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// We are telling go to store 100 as a variable which will use memory space</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>variable</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// If we want to get the address in memory for our variable we need to do this</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>address</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>variable</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(<span style=color:#a6e22e>address</span>, <span style=color:#a6e22e>variable</span>) <span style=color:#75715e>// outputs something like 0xc00003c768 100</span>
</span></span></code></pre></div><h2 id=arrays-and-linked-lists>Arrays and linked lists<a hidden class=anchor aria-hidden=true href=#arrays-and-linked-lists>#</a></h2><h3 id=linked-lists>Linked lists<a hidden class=anchor aria-hidden=true href=#linked-lists>#</a></h3><p>A linked list contains a reference to the location of the next item in the list, this way a bunch of memory addresses can be linked together.</p><p>Example:</p><pre tabindex=0><code>a-&gt;b-&gt;c-&gt;d-&gt;null
</code></pre><p>This feature allow items to be stored anywhere in memory, you can always reach them using the address stored in the list.</p><h3 id=arrays>Arrays<a hidden class=anchor aria-hidden=true href=#arrays>#</a></h3><p>An array is a continous list stored in memory where you know the location and value of all items.</p><p>Example:</p><pre tabindex=0><code>[]int{0,1,2,3,4}
</code></pre><p>This forces an array to allocate continous space in memory leading to data relocation when more space is needed and no contigous space in memory is available.</p><h3 id=arrays-vs-linked-lists>Arrays vs Linked lists<a hidden class=anchor aria-hidden=true href=#arrays-vs-linked-lists>#</a></h3><ul><li>Arrays are great if you want to read random or non-contigous elements.</li><li>Linked lists are great if you are going to read all the items one at a time.</li></ul><h3 id=terminology>Terminology<a hidden class=anchor aria-hidden=true href=#terminology>#</a></h3><p>The elements in an array are numbered, most programming languages start with 0 and not 1. When you see a reference to an array element located at index 1 it is refering to the second element of the array and not the first one.</p><blockquote><p>&#x1f4a1; The position of an element in an array is called <em>index</em>.</p></blockquote><p>These are the run times for common operations on arrays and linked lists:</p><table><thead><tr><th></th><th>Arrays</th><th>Lists</th></tr></thead><tbody><tr><td>Reading</td><td>O(1)</td><td>O(n)</td></tr><tr><td>Insertion</td><td>O(n)</td><td>O(1)</td></tr></tbody></table><h3 id=insertions>Insertions<a hidden class=anchor aria-hidden=true href=#insertions>#</a></h3><p>Whit lists it is easy to insert, you need to change the pointers to the next and current elements.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>node</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Value</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>node</span>{<span style=color:#ae81ff>10</span>, <span style=color:#66d9ef>nil</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Imagine we need to insert another node into our list</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>{<span style=color:#ae81ff>5</span>, <span style=color:#66d9ef>nil</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Imagine we need to insert another node into our list</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>{<span style=color:#ae81ff>5</span>, <span style=color:#66d9ef>nil</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;root is %v and next is %v\n&#34;</span>, <span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// Output: root is {10 0xc000108050} and next is &amp;{5 &lt;nil&gt;}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Lets imagine now they asks us to insert a new node with value 8 after the first node.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>{<span style=color:#ae81ff>8</span>, <span style=color:#66d9ef>nil</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;root is %v and next is %v, and next.Next is %v&#34;</span>, <span style=color:#a6e22e>root</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span>, <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span>.<span style=color:#a6e22e>Next</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// Output: root is {10 0xc000096260} and next is &amp;{8 0xc000096230}, and next.Next is &amp;{5 &lt;nil&gt;}</span>
</span></span></code></pre></div><p>Go playground: <a href=https://go.dev/play/p/V_zOwyM936O>https://go.dev/play/p/V_zOwyM936O</a></p><h3 id=deletions>Deletions<a hidden class=anchor aria-hidden=true href=#deletions>#</a></h3><p>When it comes to deletions the situation doesn&rsquo;t change much, lists are better, you just need to move the pointer and &#x1f4a3; an item is off the list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// main()</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>node</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Val</span>  <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Next</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>{<span style=color:#ae81ff>10</span>, <span style=color:#66d9ef>nil</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>{<span style=color:#ae81ff>9</span>, <span style=color:#66d9ef>nil</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>{<span style=color:#ae81ff>8</span>, <span style=color:#66d9ef>nil</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Next</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Now let&#39;s suppose we only want even numbers in our list,</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// so we need to remove the 9</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span> = <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span>.<span style=color:#a6e22e>Next</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>root</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Val</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>Next</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Go playground: <a href=https://go.dev/play/p/HWwpT8tteu1>https://go.dev/play/p/HWwpT8tteu1</a></p><p>With arrays everything needs to be moved but unlike insertions deletions will always work.</p><blockquote><p>&#x1f4a1; array insertions can fail when there is no more space in memory and the array cannot be dynamically extended.</p></blockquote><h3 id=bookmark>&#x1f516;<a hidden class=anchor aria-hidden=true href=#bookmark>#</a></h3><p>It is a common practice to keep track of the first and last element of a linked list, that way removing or inserting at the start / end of the list is always O(1).</p><p>There are two different types of access, <em>random access</em> and <em>sequential access</em>.</p><p><strong>&#x1f4cc; Linked lists can only do sequential access</strong></p><p><strong>&#x1f4cc; Arrays are better if you need random access</strong></p><blockquote><p>&#x1f4a1; Random access means that you can inmmediatly jump to any point of the array.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>5</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Random access to 4</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>arr</span>[<span style=color:#ae81ff>3</span>] <span style=color:#75715e>// prints 4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// With a list you will get sequential access:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Image the list above is represented using linked nodes: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;nil</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>Next</span>.<span style=color:#a6e22e>Next</span>.<span style=color:#a6e22e>Next</span> <span style=color:#75715e>// prints 4</span>
</span></span></code></pre></div><p>Common run time for operations on arrays and linked lists.</p><table><thead><tr><th></th><th>Arrays</th><th>Lists</th></tr></thead><tbody><tr><td>Reading</td><td>O(1)</td><td>O(n)</td></tr><tr><td>Writing</td><td>O(n)</td><td>0(1)</td></tr><tr><td>Deleting</td><td>O(n)</td><td>O(1)</td></tr></tbody></table><h2 id=selection-sort>Selection sort<a hidden class=anchor aria-hidden=true href=#selection-sort>#</a></h2><p>Given a comparable value sort by picking the highest (desc) / lowest (asc) value and moving it to the righ position, this is know as in place sorting, do this until your list is sorted.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Sort the given array</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>arr</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>20</span>,<span style=color:#ae81ff>234</span>,<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>23</span>,<span style=color:#ae81ff>90</span>,<span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>selectionSort</span>(<span style=color:#a6e22e>list</span> []<span style=color:#66d9ef>int</span>) []<span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>n</span> = len(<span style=color:#a6e22e>list</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>minIdx</span> = <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>j</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span>; <span style=color:#a6e22e>j</span> &lt; <span style=color:#a6e22e>n</span>; <span style=color:#a6e22e>j</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>j</span>] &lt; <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>minIdx</span>] {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>minIdx</span> = <span style=color:#a6e22e>j</span>
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>i</span>], <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>minIdx</span>] = <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>minIdx</span>], <span style=color:#a6e22e>list</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// See how the array changes on every pass.</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>list</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>list</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// main()</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>selectionSort</span>(<span style=color:#a6e22e>arr</span>))
</span></span></code></pre></div><p>Go playground: <a href=https://go.dev/play/p/FHhposwF6Nk>https://go.dev/play/p/FHhposwF6Nk</a></p><h2 id=chapter-3---recursion>Chapter 3 - Recursion<a hidden class=anchor aria-hidden=true href=#chapter-3---recursion>#</a></h2><p>In computer science, recursion is a method of solving a computational problem where the solution depends on solutions to smaller instances of the same problem.</p><p>To be able to write a recursive function, you need one or several base cases and one recursive case, in plain words this means that your function needs rules to know when to stop and what to do when those rules are not met.</p><p>The most famous example to practice recursion is creating a function that returns the nth number in Fibonnaci&rsquo;s sequence:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>nthFib</span>(<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Initial base case, when the requested number is 0 we know</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// we don&#39;t need to do any work.</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Another base case: The first 2 fib numbers after 0 are 1</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 0 1 1</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span> <span style=color:#f92672>&lt;=</span><span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Now we need to write our recursive case, we know the fib sequence is created</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// by adding the 2 previous numbers before the one you need.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>	// To illustrate, let&#39;s calculate the first 5 fib numbers:</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 0, 1, 1, 2, 3, 5.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// From that example we visualize that the fifth fib number is creating by</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// adding the numbers at position 4 and 3, or 3 + 2.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Therefore we can create our recursive case by saying:</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>nthFib</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>nthFib</span>(<span style=color:#a6e22e>n</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// This code will always work because we now that in order to hit our recursive</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// case our n number needs to be &gt; 0.</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Go playground: <a href=https://go.dev/play/p/Y5Vdg6VcMUW>https://go.dev/play/p/Y5Vdg6VcMUW</a></p><h3 id=the-stack>The stack<a hidden class=anchor aria-hidden=true href=#the-stack>#</a></h3><p>A stack is a data structure where new information is pushed to the front of the stack and when you need to retrieve a workload, you will always take whatever is at the very top of the stack.</p><p>Example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// considering we have push and read as functions and:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// push adds information to the top of our stack while read</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// retrieves the record at the top, then.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>push</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>push</span>(<span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>push</span>(<span style=color:#ae81ff>7</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println(<span style=color:#a6e22e>stack</span>.<span style=color:#a6e22e>read</span>()) <span style=color:#75715e>// prints 7</span>
</span></span></code></pre></div><p>Your computer performs processes using an internal stack knwon as the <code>call stack</code>, it will allocate a stack frame for every action it needs to perform.</p><h3 id=recursion-and-the-call-stack>Recursion and the call stack<a hidden class=anchor aria-hidden=true href=#recursion-and-the-call-stack>#</a></h3><p>Recursive functions leverage the internal call stack to avoid using additional data structures.</p><p>Imagine a function called <code>factorial(int num) int</code> that calculates the factorial value of the given number, to write it in a recursive way we do something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>factorial</span>(<span style=color:#66d9ef>int</span> <span style=color:#a6e22e>num</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// declare your base case</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// declare your recursive case</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>factorial</span>(<span style=color:#a6e22e>num</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s check how the call stack will be used to calculate the result of <code>factorial(3)</code></p><p><em>on the stack I will use f to refer to factorial</em></p><table><thead><tr><th>Code</th><th>Stack</th></tr></thead><tbody><tr><td>factorial(3)</td><td>f(3)</td></tr><tr><td>factorial(2)</td><td>f(3) -> f(2)</td></tr><tr><td>factorial(1)</td><td>f(3) -> f(2) -> f(1)</td></tr><tr><td>(base case) = return 1</td><td>f(3) -> f(2)</td></tr><tr><td>(2 * 1) = return 2</td><td>f(3)</td></tr><tr><td>(3 * 2) = return 6</td><td>(empty)</td></tr></tbody></table><p>See how first the program performs three calls to factorial and then starts using the result to compute the subsequent still pending calls in the stack.</p><h3 id=alternatives-to-stacks>Alternatives to stacks<a hidden class=anchor aria-hidden=true href=#alternatives-to-stacks>#</a></h3><ul><li>Write your code using loops</li><li>You can use <code>tail recursion</code> (advanced) (not supported by all programming languages)</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://victoravelar.dev/tags/algorithms/>Algorithms</a></li></ul><nav class=paginav><a class=prev href=https://victoravelar.dev/articles/2023/yearbook/><span class=title>¬´ Prev</span><br><span>2023 Yearbook</span>
</a><a class=next href=https://victoravelar.dev/articles/2022/yearbook/><span class=title>Next ¬ª</span><br><span>2022 Yearbook</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share My Notes on Grooking Algorithms on x" href="https://x.com/intent/tweet/?text=My%20Notes%20on%20Grooking%20Algorithms&amp;url=https%3a%2f%2fvictoravelar.dev%2farticles%2f2022%2fmy-notes-on-grooking-algorithms%2f&amp;hashtags=algorithms"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share My Notes on Grooking Algorithms on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fvictoravelar.dev%2farticles%2f2022%2fmy-notes-on-grooking-algorithms%2f&amp;title=My%20Notes%20on%20Grooking%20Algorithms&amp;summary=My%20Notes%20on%20Grooking%20Algorithms&amp;source=https%3a%2f%2fvictoravelar.dev%2farticles%2f2022%2fmy-notes-on-grooking-algorithms%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share My Notes on Grooking Algorithms on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fvictoravelar.dev%2farticles%2f2022%2fmy-notes-on-grooking-algorithms%2f&title=My%20Notes%20on%20Grooking%20Algorithms"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share My Notes on Grooking Algorithms on whatsapp" href="https://api.whatsapp.com/send?text=My%20Notes%20on%20Grooking%20Algorithms%20-%20https%3a%2f%2fvictoravelar.dev%2farticles%2f2022%2fmy-notes-on-grooking-algorithms%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share My Notes on Grooking Algorithms on telegram" href="https://telegram.me/share/url?text=My%20Notes%20on%20Grooking%20Algorithms&amp;url=https%3a%2f%2fvictoravelar.dev%2farticles%2f2022%2fmy-notes-on-grooking-algorithms%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://victoravelar.dev/>VictorAvelar</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>